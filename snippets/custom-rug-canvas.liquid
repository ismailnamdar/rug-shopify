<div id="rug-canvas-container" style="position: relative; width: 100%;display:none;">
  <canvas id="rug-canvas" style="width:100%; height:360px; touch-action:none;"></canvas>
  <div class="custom-rug-top-toolbar">
    <div style="font-size: 12px; line-height: 14px; display: flex; flex-direction: column; width: 40px; text-align:center; color: white">
      Change Photo
      <button id="rug-canvas-change-photo" class="custom-rug-action-button" style="margin-top: 6px;">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cloud-upload" aria-hidden="true"><path d="M12 13v8"></path><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"></path><path d="m8 17 4-4 4 4"></path></svg>
      </button>
    </div>
  </div>

  <div class="custom-rug-bottom-toolbar">
    <button id="rug-canvas-rotate" class="custom-rug-action-button" style="margin-bottom: 10px;">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rotate-ccw" aria-hidden="true"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
    </button>
    <button id="rug-canvas-scale-up" class="custom-rug-action-button">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-plus" aria-hidden="true"><path d="M5 12h14"></path><path d="M12 5v14"></path></svg>
    </button>
    <button id="rug-canvas-scale-down" class="custom-rug-action-button">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-minus" aria-hidden="true"><path d="M5 12h14"></path></svg>
    </button>
  </div>
</div>

<style>
  .custom-rug-action-button {
    height: 36px;
    width: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .custom-rug-top-toolbar {
    position: absolute;
    right: 10px;
    top: 12px;
  }
  .custom-rug-bottom-toolbar {
    position: absolute;
    right: 10px;
    bottom: 12px;
  }
</style>

<script>
/* -------------------------------------------------------------
   CONSTANTS
------------------------------------------------------------- */
const API_BASE_URL = "https://rug-staging.vercel.app"
const SUPABASE_URL = "https://fezniiknsjfdseplablo.supabase.co";
const canvas = document.getElementById("rug-canvas");
const changePhotoButton = document.getElementById("rug-canvas-change-photo");
const rotateButton = document.getElementById("rug-canvas-rotate");
const scaleUpButton = document.getElementById("rug-canvas-scale-up");
const scaleDownButton = document.getElementById("rug-canvas-scale-down");
const ctx = canvas.getContext("2d");
const handlePositions = {};
const center = { x: 0, y: 0 };
const canvasScale = {
    w: 14,
    h: 14,
}
const sizes = {
    'circle': {
        "3'X3'": {
            name: "3'X3'",
            wFeet: 3,
            hFeet: 3,
            w: 10,
            h: 10,
        },
        "4'X4'": {
            name: "4'X4'",
            wFeet: 4,
            hFeet: 4,
            w: 10,
            h: 10,
        },
        "5'X5'": {
            name: "5'X5'",
            wFeet: 5,
            hFeet: 5,
            w: 10,
            h: 10,
        },
        "6'X6'": {
            name: "6'X6'",
            wFeet: 6,
            hFeet: 6,
            w: 10,
            h: 10,
        },
        "8'X8'": {
            name: "8'X8'",
            wFeet: 8,
            hFeet: 8,
            w: 10,
            h: 10,
        }
    },
    'rectangle': {
        "2'X3'": {
            name: "2'X3'",
            wFeet: 3,
            hFeet: 2,
            w: 10,
            h: 2 * 10 / 3,
        },
        "3'X5'": {
            name: "3'X5'",
            wFeet: 5,
            hFeet: 3,
            w: 10,
            h: 6,
        },
        "5'X7'": {
            name: "5'X7'",
            wFeet: 7,
            hFeet: 5,
            w: 10,
            h: 5 * 10 / 7,
        },
        "8'X10'": {
            name: "8'X10'",
            wFeet: 10,
            hFeet: 8,
            w: 10,
            h: 8,
        },
        "8'X12'": {
            name: "8'X12'",
            wFeet: 12,
            hFeet: 8,
            w: 10,
            h: 8,
        }
    },
    'runner': {
        "2.5'X7'": {
            name: "2.5'X7'",
            wFeet: 7,
            hFeet: 2.5,
            w: 10,
            h: 5,
        },
        "2.5'X10'": {
            name: "2.5'X10'",
            wFeet: 10,
            hFeet: 2.5,
            w: 10,
            h: 5,
        },
        "5'X10'": {
            name: "5'X10'",
            wFeet: 10,
            hFeet: 5,
            w: 10,
            h: 5,
        },
    }
}

/* -------------------------------------------------------------
   INTERNAL STATE
------------------------------------------------------------- */
let fgImg = null;
let bgImg = null;
let backgroundRemoving = false;
let shownImage = 'main'; // 'main' | 'background-removed'
let fgUrl = null;
let fgUrlRemoved = null;
let uploadedImage = {}; // previewDataUrl
let removedBackground = false

let shape = {{ shape | default: "rectangle" | json}}; // circle | rectangle | runner
let shapeSize = {{ size | default: "2'X3'" | json }};
console.log(shape, shapeSize, "{{shape}}", "{{size}}");
let dimension = { wFeet: 5, hFeet: 3, w: 10, h: 6 }; // You can customize
let scalePct = 100;
let rotationDeg = 0;
let selected = true;
let bgColor = "#000000"
let interaction = null;

/* -------------------------------------------------------------
   HELPER FUNCTIONS
------------------------------------------------------------- */

// Compute rug mask dimensions
function maskDims(width, height) {
    const min = Math.min(width, height);
    const minIsWidth = min === width;
    const minIsHeight = min === height;
    const selectedDimension = sizes[shape][shapeSize]
    const ratio = selectedDimension.h / selectedDimension.w;

    if (shape === "runner") {
      // const w = Math.min(Math.floor(min * 0.75), Math.floor(width * 0.8));
      const w= Math.floor(width / canvasScale.w * selectedDimension.w)
      const h = Math.floor(w * ratio);
      return { w, h };
    }
    if (shape === "rectangle") {
      const w = Math.floor(width / canvasScale.w * selectedDimension.w);
      const h = Math.floor(w * ratio);
      return { w: w, h: h };
    }
    const size = minIsWidth ? Math.floor(width / canvasScale.w * selectedDimension.w) : Math.floor(height / canvasScale.h * selectedDimension.h);
    // const size = Math.floor(min * 0.8);
    return { w: size, h: size };
  }

// Compute cover drawing size
function computeDrawDims(w, h, iw, ih, scalePct) {
  const rectRatio = w / h;
  const imgRatio = iw / ih;
  let dw, dh;

  if (imgRatio < rectRatio) {
    dh = h;
    dw = h * imgRatio;
  } else {
    dw = w;
    dh = w / imgRatio;
  }

  return { dw: dw * (scalePct / 100), dh: dh * (scalePct / 100) };
}

// Draw image cover into mask
function drawImageCover(ctx, img, x, y, w, h, scale, rotation, cover) {
  const iw = img.naturalWidth;
  const ih = img.naturalHeight;

  const rectRatio = w / h; // 100 / 50
  const imgRatio = iw / ih; // 50 / 100
  let dw, dh;

  // Bg image is cover and user loaded image is contain.
  if (cover ? imgRatio > rectRatio : imgRatio < rectRatio) {
    dh = h;
    dw = h * imgRatio;
  } else {
    dw = w;
    dh = w / imgRatio;
  }

  dw *= scale / 100;
  dh *= scale / 100;

  const cx = x + w / 2;
  const cy = y + h / 2;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rotation * Math.PI / 180);
  ctx.drawImage(img, -dw / 2, -dh / 2, dw, dh);
  ctx.restore();
}

/* -------------------------------------------------------------
   MAIN DRAW FUNCTION
------------------------------------------------------------- */
function draw({ measurement = true, hideBorder = false } = {}) {
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;

  canvas.width = width * window.devicePixelRatio;
  canvas.height = height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

  ctx.clearRect(0, 0, width, height);

  if (bgImg) drawImageCover(ctx, bgImg, 0, 0, width, height, 100, 0, true);

  let { w, h } = maskDims(width, height);

  const x = (width - w) / 2;
  const y = (height - h) / 2;

  function makeMaskPath() {
    ctx.beginPath();
    if (shape === "circle") {
      ctx.arc(x + w / 2, y + h / 2, Math.min(w, h) / 2, 0, Math.PI * 2);
    } else {
      ctx.rect(x, y, w, h);
    }
  }

  ctx.save();
  makeMaskPath();
  ctx.clip();

  ctx.fillStyle = bgColor || "#000000";
  ctx.fillRect(x, y, w, h);

  if (fgImg) drawImageCover(ctx, fgImg, x, y, w, h, scalePct, rotationDeg);

  ctx.restore();

  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = "black";
  makeMaskPath();
  ctx.stroke();
  ctx.restore();

  /* ---- HANDLE BORDER + HANDLES ---- */
  if (fgImg && selected && !hideBorder) {
    const iw = fgImg.naturalWidth;
    const ih = fgImg.naturalHeight;
    const { dw, dh } = computeDrawDims(w, h, iw, ih, scalePct);

    const cx = x + w / 2;
    const cy = y + h / 2;
    center.x = cx;
    center.y = cy;

    const rad = rotationDeg * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);

    const hw = dw / 2, hh = dh / 2;

    function rot(px, py) {
      return {
        x: cx + px * cos - py * sin,
        y: cy + px * sin + py * cos,
      };
    }

    const corners = {
      nw: rot(-hw, -hh),
      ne: rot(hw, -hh),
      se: rot(hw, hh),
      sw: rot(-hw, hh),
    };

    ctx.strokeStyle = "#2563eb";
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(corners.nw.x, corners.nw.y);
    ctx.lineTo(corners.ne.x, corners.ne.y);
    ctx.lineTo(corners.se.x, corners.se.y);
    ctx.lineTo(corners.sw.x, corners.sw.y);
    ctx.closePath();
    ctx.stroke();

    const dirX = corners.ne.x - cx;
    const dirY = corners.ne.y - cy;
    const len = Math.hypot(dirX, dirY);
    const rotatePos = {
      x: corners.ne.x + dirX / len * 16,
      y: corners.ne.y + dirY / len * 16
    };

    handlePositions.nw = corners.nw;
    handlePositions.ne = corners.ne;
    handlePositions.se = corners.se;
    handlePositions.sw = corners.sw;
    handlePositions.rotate = rotatePos;

    ctx.fillStyle = "#2563eb";
    const s = 10;

    Object.values(corners).forEach(pt => {
      ctx.fillRect(pt.x - s / 2, pt.y - s / 2, s, s);
    });

    ctx.beginPath();
    ctx.arc(rotatePos.x, rotatePos.y, 8, 0, Math.PI * 2);
    ctx.fill();
  }

  if (measurement === false) return;
  const selectedDimension = sizes[shape][shapeSize]
  // --- Measurement arrows ---
  ctx.save();
  ctx.strokeStyle = "#000000"; // neutral-400
  ctx.fillStyle = "#000000"; // neutral-600
  ctx.lineWidth = 2;
  ctx.font = "bold 18px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";

  // Horizontal arrow (width)
  const hLineY = y + h + 18
  const hx1 = x;
  const hx2 = x + w;

  // main line
  ctx.beginPath();
  ctx.moveTo(hx1, hLineY);
  ctx.lineTo(hx2, hLineY);
  ctx.stroke();

  const arrowSize = 6;
  // left flat cap
  ctx.beginPath();
  ctx.moveTo(hx1, hLineY - arrowSize);
  ctx.lineTo(hx1, hLineY + arrowSize);
  ctx.stroke();

  // right flat cap
  ctx.beginPath();
  ctx.moveTo(hx2, hLineY - arrowSize);
  ctx.lineTo(hx2, hLineY + arrowSize);
  ctx.stroke();

  const hTextY = hLineY + 16;
  ctx.textAlign = "center";
  ctx.fillText(`${selectedDimension.wFeet}'`, x + w / 2, hTextY);

  // Vertical arrow (height)
  const vLineX = x - 20;
  const vy1 = y;
  const vy2 = y + h;

  ctx.beginPath();
  ctx.moveTo(vLineX, vy1);
  ctx.lineTo(vLineX, vy2);
  ctx.stroke();

  // top flat cap
  ctx.beginPath();
  ctx.moveTo(vLineX - arrowSize, vy1);
  ctx.lineTo(vLineX + arrowSize, vy1);
  ctx.stroke();

  // bottom flat cap
  ctx.beginPath();
  ctx.moveTo(vLineX - arrowSize, vy2);
  ctx.lineTo(vLineX + arrowSize, vy2);
  ctx.stroke();

  ctx.textAlign = "left";
  const vTextX = vLineX - 20;
  ctx.fillText(`${selectedDimension.hFeet}'`, vTextX, y + h / 2 + 4);

  ctx.restore();
}

/* -------------------------------------------------------------
   POINTER EVENTS
------------------------------------------------------------- */
function localPointer(e) {
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

canvas.addEventListener("pointerdown", e => {
  const p = localPointer(e);
  let hit = null;
  const threshold = 12;

  for (const [name, pt] of Object.entries(handlePositions)) {
    if (Math.hypot(p.x - pt.x, p.y - pt.y) <= threshold) hit = name;
  }

  if (hit) {
    selected = true;
    if (hit === "rotate") {
      interaction = {
        mode: "rotate",
        startAngle: Math.atan2(p.y - center.y, p.x - center.x),
        startRotation: rotationDeg
      };
    } else {
      interaction = {
        mode: "scale",
        startDist: Math.hypot(p.x - center.x, p.y - center.y),
        startScale: scalePct
      };
    }
    return;
  }

  // Non-handle click selects/deselects
  // No handle hit → check if click is inside the image bounds
  const fg = fgImg;
  if (fg && canvas) {
    const width = Math.round(canvas.clientWidth);
    const height = Math.round(canvas.clientHeight);
    const { w, h } = maskDims(width, height);
    const x = Math.floor((width - w) / 2);
    const y = Math.floor((height - h) / 2);

    const iw = fg.naturalWidth;
    const ih = fg.naturalHeight;
    const { dw, dh } = computeDrawDims(w, h, iw, ih, scalePct);

    const cx = x + w / 2;
    const cy = y + h / 2;
    const rad = (rotationDeg * Math.PI) / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);

    const dx = p.x - cx;
    const dy = p.y - cy;

    // Transform point into image-local space (unrotate)
    const localX = dx * cos + dy * sin;
    const localY = -dx * sin + dy * cos;

    if (Math.abs(localX) <= dw / 2 && Math.abs(localY) <= dh / 2) {
      // Clicked on the image → select it
      selected = true;
    } else {
      // Clicked outside → deselect
      selected = false;
    }
  } else {
    // No image loaded → always deselect
    selected = false;
  }

  draw();
});

canvas.addEventListener("pointermove", e => {
  if (!interaction) return;

  const p = localPointer(e);

  if (interaction.mode === "scale") {
    const d = Math.hypot(p.x - center.x, p.y - center.y);
    const next = interaction.startScale * (d / interaction.startDist);
    scalePct = Math.max(10, Math.min(400, next));
  }

  if (interaction.mode === "rotate") {
    const a = Math.atan2(p.y - center.y, p.x - center.x);
    rotationDeg = (interaction.startRotation + (a - interaction.startAngle) * 180 / Math.PI) % 360;
    if (rotationDeg < 0) rotationDeg += 360;
  }

  draw();
});

canvas.addEventListener("pointerup", () => {
  interaction = null;
});

async function uploadPreview(blob) {
    // STEP 1 → Get signed upload URL from your backend
    const res = await fetch(`${API_BASE_URL}/api/media/upload-preview`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        fileName: "preview.png",
      })
    });

    if (!res.ok) {
      console.error("Failed to request upload preview URL");
      return null;
    }

    const { bucket, path, token, supabaseUrl } = await res.json();

    // STEP 2 → Construct upload URL
    const uploadUrl = `${SUPABASE_URL}/storage/v1/object/upload/sign/${bucket}/${path}?token=${token}`;

    // STEP 3 → Upload the blob directly (NO FORM DATA — raw body only)
    const uploadRes = await fetch(uploadUrl, {
      method: "PUT",
      headers: {
        "Content-Type": "image/png"
      },
      body: blob
    });

    if (!uploadRes.ok) {
      throw new Error("Failed to upload preview to Supabase");
    }

    return path; // returned stored file path
  }
  

/* -------------------------------------------------------------
   IMAGE LOADING API
------------------------------------------------------------- */

window.CanvasRugEditor = {
  reset() {
    // Clear previous urls. Ideally store thse in a variable to return back to in the future.
    fgUrl = null;
    fgUrlRemoved = null;
    fgImg = null;
    
    backgroundRemoving = false;
    shownImage = 'main';
    removeBackground = false;
    uploadedImage = {};
    // setCheckoutObject(undefined);
    // setNeedFixingOpen(false);
    // setFixingNote(false);
    // setUploadProgress(0);
    // setUseUploadedFile(false);
  },
  loadForeground(src) {
    // HIDE
    // Hide main gallery
    $(`#main-gallery`).css('display', 'none');
    // Hide main upload image button
    $('#custom-rug-upload-image-button-container').css('display', 'none');
    // Hide main price
    $('#main-price').css('display', 'none');

    // SHOW
    $(`#rug-canvas-container`).css('display', 'block');
    $('#custom-rug-remove-background-section').css('display', 'block');
    $('#custom-rug-background-color-section').css('display', 'block');
    $('#custom-rug-add-to-cart').css('display', 'flex');
    $('#custom-rug-properties-section').css('display', 'block');

    fgUrl = src;
    fgImg = new Image();
    fgImg.onload = draw;
    fgImg.src = src;
  },
  loadBackground(src) {
    bgImg = new Image();
    bgImg.onload = draw;
    bgImg.src = src;
  },
  setShape(s) {
    console.log({ selectedShape: s });
    shape = s;
    shapeSize = Object.keys(sizes[shape])[0];
    draw();
  },
  setSize(s) {
    shapeSize = s
    draw();
  },
  setDimension(obj) {
    dimension = obj; // { wFeet, hFeet, w, h }
    draw();
  },
  setScale(v) {
    scalePct = v;
    draw();
  },
  setRotation(v) {
    rotationDeg = v;
    draw();
  },
  setBgColor(v) {
    bgColor = v;
    draw();
  },
  setUploadedImage(v) {
    uploadedImage = v;
    // If backgroundRemoving already true, that means user is already trying to remove the background
    if (backgroundRemoving) {
        this.removeBackground();
    }
  },
  startRemoveBg() {
    if (removedBackground) {
        const img = new Image();
        img.onload = () => {
            fgImg = img;
            draw();
        };
        img.src = shownImage === 'main' ? fgUrlRemoved : fgUrl;
        shownImage = shownImage === 'main' ? 'background-removed' : 'main';
    } else {
        this.removeBackground()
    }
  },
  async exportPNG() {
    draw({ hideBorder: true });

    return await new Promise((resolve, reject) => {
      canvas.toBlob(async function(blob) {
        if (!blob) return reject("Error");

        const path = await uploadPreview(blob);
        console.log("Preview stored at:", path);

        // Update global reference
        uploadedImage.previewPath = path;

        resolve(path);
      }, "image/png");
    });
  },
  async createMedia(originalPath, previewPath, mimeType, backgroundColor, removeBg) {
    const response = await fetch(`${API_BASE_URL}/api/media`, {
      method: 'POST',
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        original_path: originalPath,
        preview_path: previewPath,
        mime_type: mimeType,
        background_color: backgroundColor || null,
        remove_bg: removeBg || false,
      })
    });

    return await response.json();
  },
  async handleClickAddToCart() {
    // 1. Export PNG preview
    const previewPath = await this.exportPNG();

    const {
      path: originalPath,
      mimeType,
    } = uploadedImage;

    console.log({ previewPath });

    // 2. Tell your backend to create entry
    const {
      data,
      original_file_url: originalFileUrl,
      preview_file_url: previewFileUrl
    } = await this.createMedia(
      originalPath,
      previewPath,
      mimeType,
      bgColor,
      shownImage === "background-removed"
    );

    $('#custom-rug-properties-section input[name=\"properties[__bgColor]\"]').val(bgColor);
    $('#custom-rug-properties-section input[name=\"properties[__removeBg]\"]').val(removedBackground ? "true" : "false");
    $('#custom-rug-properties-section input[name=\"properties[__scale]\"]').val(scalePct);
    $('#custom-rug-properties-section input[name=\"properties[__rotation]\"]').val(rotationDeg);
    $('#custom-rug-properties-section input[name=\"properties[Original image]\"]').val(originalFileUrl);
    $('#custom-rug-properties-section input[name=\"properties[Product preview image]\"]').val(previewFileUrl);

    // 3. Store checkout object globally so Shopify cart can use it
    // Adjust properties of the item
    window.checkoutObject = {
      id: data.id,
      originalFileUrl,
      previewFileUrl,
      shape,
      dimension,
      bgColor,
      removedBackground,
      ...data
    };

    $('#custom-rug-submit-button').click();
    console.log("Checkout Object", window.checkoutObject);
  },
  async removeBackground() {
    try {
        backgroundRemoving = true;
        console.log('Removing background');
        // Wait for uploaded image preview url for better performance on remove bg.
        if (uploadedImage.previewDataUrl == null) return;

        console.log(`Removing background started for ${uploadedImage.previewDataUrl}`);
        const fd = new FormData();
        fd.append("image_file", uploadedImage.previewDataUrl);

        const res = await fetch(`${API_BASE_URL}/api/media/remove-bg`, {
            method: "POST",
            body: fd
        });

        if (!res.ok) {
            throw new Error("Background removal failed");
        }

        const blob = await res.blob();
        const previewUrl = URL.createObjectURL(blob);

        const img = new Image();
        img.onload = () => {
            fgImg = img;
            draw();
            backgroundRemoving = false;
            shownImage = "background-removed";
            fgUrlRemoved = previewUrl;
            removedBackground = true;
        };

        img.src = previewUrl;

    } catch (err) {
        console.error("Remove BG Error:", err);
        backgroundRemoving = false;
        shownImage = "main";
    }
  }
};


scaleUpButton.addEventListener("click", () => {
  CanvasRugEditor.setScale(scalePct + 10);
});

scaleDownButton.addEventListener("click", () => {
  CanvasRugEditor.setScale(Math.max(10, scalePct - 10));
});

rotateButton.addEventListener("click", () => {
  CanvasRugEditor.setRotation((rotationDeg - 45) % 360);
});

changePhotoButton.addEventListener("click", () => {
  $('#custom-rug-image').click();
});

CanvasRugEditor.loadBackground("{{ 'canvas-background.jpg' | asset_url }}");
</script>
