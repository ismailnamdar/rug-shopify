<div id="star-{{ section.id }}" class="star-ratings__container {{ section.id }}">
  {% if section.settings.anchor_link %}
    <a
      href="{{ section.settings.anchor_link }}"
      data-scroll="true"
      class="star-ratings__link"
    >
  {% endif %}
    {% render 'junip-product-summary', product: section.settings.product %}
  {% if section.settings.anchor_link %}
    </a>
  {% endif %}
</div>
<style>
  .star-ratings__container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 20px 0;
    width: 100%;
  }

  .star-ratings__container .junip-product-summary-star {
    height: 30px !important;
    width: 30px !important;
  }

  .star-ratings__container .junip-stars-filled {
    gap: 3px;
  }

  .star-ratings__container .junip-stars-outline {
    gap: 3px;
  }

  .star-ratings__container .junip-product-summary-review-count {
    text-decoration: underline;
    text-decoration-thickness: 2px;
    text-underline-offset: 2px;
    color: #4D4D4D;
    font-family: 'Avenir', sans-serif;
    font-size: 26px;
    font-weight: 200;
    line-height: normal;
    margin-left: 10px;
  }
</style>
<script>
  (function () {
    const root = document.getElementById('star-{{ section.id }}');
    if (!root) return;

    let widthOriginal;
  function rewriteCounts() {
    // Tweak as desired; this keeps it broad so it catches summary/review spots
    const containers = root.querySelectorAll('.junip-product-summary, .junip-product-review, [class*="junip"]');
    containers.forEach(el => {
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
      let node;
      while ((node = walker.nextNode())) {
        const updated = node.nodeValue.replace(/\((\d+)\)/g, '$1 Reviews');
        if (updated !== node.nodeValue) node.nodeValue = updated;
      }
    });
  }

  function adjustWidth() {
    const container = root.querySelector('.junip-stars-filled');
    
    if (widthOriginal == null || widthOriginal === "") {
      widthOriginal = container.style.width;
    }

    container.style.width = `calc(${widthOriginal} + 7px)`;
  }

  document.addEventListener('DOMContentLoaded', () => {
    rewriteCounts();
    // This is because we have a gap: 3px; now. We have to adjust the filled star width
    adjustWidth();

    // Catch Junipâ€™s async render (and product grid pagination, etc.)
    const mo = new MutationObserver(mutations => {
      for (const m of mutations) {
        for (const n of m.addedNodes) {
          if (!(n instanceof Element)) continue;
          if (
            n.matches('.junip-product-summary, .junip-product-review, [class*="junip"]') ||
            n.querySelector('.junip-product-summary, .junip-product-review, [class*="junip"]')
          ) {
            rewriteCounts(n);
          }

          if (
            n.matches('.junip-stars-filled') ||
            n.querySelector('.junip-stars-filled')
          ) {
            adjustWidth(n);
          }
        }
      }
    });
    mo.observe(document.body, { childList: true, subtree: true });

    // Re-run when a Shopify section reloads in the theme editor
    document.addEventListener('shopify:section:load', e => {
      rewriteCounts(e.target)
      adjustWidth(e.target);
    });
    });
})();

</script>

{% schema %}
{
  "name": "Junip Star Ratings",
  "settings": [
    {
      "type": "product",
      "id": "product",
      "label": "Product"
    },
    {
      "type": "text",
      "id": "anchor_link",
      "label": "Anchor or URL", 
      "info": "Enter an anchor (e.g. #reviews) or full URL to link to when clicking the rating."
    }
  ],
  "presets": [
    {
      "name": "Junip Star Ratings",
      "category": "Product"
    }
  ]
}
{% endschema %}